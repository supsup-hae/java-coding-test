# 기능개발

## 📌 문제 정보
- **문제**: [기능개발](https://school.programmers.co.kr/learn/courses/30/lessons/42586)
- **난이도**: Level 2
- **풀이 날짜**: 2024-01-15

## 👓 문제 설명
프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

## 🚫 제한사항
- 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
- 작업 진도는 100 미만의 자연수입니다.
- 작업 속도는 100 이하의 자연수입니다.
- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다.

## 🖥️ 입출력 예
| progresses | speeds | return |
|------------|--------|--------|
| [93, 30, 55] | [1, 30, 5] | [2, 1] |
| [95, 90, 99, 99, 80, 99] | [1, 1, 1, 1, 1, 1] | [1, 3, 2] |

## 📝 입출력 예 설명
첫 번째 예시:
- 첫 번째 기능: 93% 완료, 1%/일 → 7일 소요
- 두 번째 기능: 30% 완료, 30%/일 → 3일 소요 (7일째 배포)
- 세 번째 기능: 55% 완료, 5%/일 → 9일 소요
- 결과: 7일째 2개 기능, 9일째 1개 기능 배포

두 번째 예시:
- 모든 기능이 1%/일로 작업
- 남은 일수: 5일, 10일, 1일, 1일, 20일, 1일
- 결과: 5일째 1개, 10일째 3개, 20일째 2개 기능 배포

### ⏱️ 소요 시간

- 시간 초과


## 문제 풀이

### 첫번째 접근
```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

class Solution {
	public int[] solution(int[] progresses, int[] speeds) {
		Deque<Integer> progressQueue = new ArrayDeque<>();
		Deque<Integer> speedQueue = new ArrayDeque<>();
		List<Integer> list = new ArrayList<>();
		for (int progress : progresses) {
			progressQueue.addLast(progress);
		}
		for (int speed : speeds) {
			speedQueue.addLast(speed);
		}

		for (int i = 0; ; i++) {
			if (progressQueue.isEmpty()) {
				break;
			}
			int peekPro = progressQueue.peekFirst();
			int peekSpeed = speedQueue.peekFirst();
			int k = (100 - peekPro) / peekSpeed;
			if ((100 - peekPro) % peekSpeed > 0) {
				k++;
			}
			for (int j = 0; j < progressQueue.size(); j++) {
				int afterSpeed = speedQueue.pollFirst();
				int afterValue = progressQueue.pollFirst() + (afterSpeed * k);
				progressQueue.addLast(afterValue);
				speedQueue.addLast(afterSpeed);
			}
			list.add(validate(progressQueue, speedQueue));

		}
		return list.stream().mapToInt(Integer::intValue).toArray();
	}

	private int validate(Deque<Integer> progressQueue, Deque<Integer> speedQueue) {
		int count = 0;
		for (int i = 0; i <= progressQueue.size(); i++) {
			int pollValue = progressQueue.pollFirst();
			if (pollValue >= 100 ) {
				count++;
				speedQueue.removeFirst();
			} else {
				progressQueue.addFirst(pollValue);
				break;
			}
		}
		return count;
	}
}
```
- Deque를 활용하면서도 기존의 Queue 방식의 데이터 접근만 생각하다보니 구현에서 시간이 더 많이 소요되었다.
- 양 방향에서 삽입과 추출이 가능한것을 알고 코드를 수정후에 테스트 케이스를 통과 했지만 제출시 테스트 케이스는 2개만 정답으로 맞았다.

### 최종 접근
- queue로 값을 순회하면서 speed에 맞게 값을 증가해 요구 조건에 맞는 값이 나오더라도 선행 작업의 배포가 되어야 같이 배포가 된다. 
1. 각 작업의 배포 가능을 구한다.
2. 작업을 진행하며 배포 가능일이 첫번째 작업일보다 빠른 작업은 함께 배포한다.
3. 첫번째 작업의 배포 가능일보다 늦은 작업이 나오면 2단계와 유사하게 해당 작업의 배포일 기준 뒤의 작업들을 배포하며 모든 작업이 완료될때 까지 진행

```java
import java.util.ArrayDeque;
import java.util.Queue;

class Solution {
	public int[] solution(int[] progresses, int[] speeds) {
		Queue<Integer> answer = new ArrayDeque<>();
		int n = progresses.length;
		int[] daysLeft = new int[n];

		for (int i = 0; i < n; i++) {
			daysLeft[i] = (int)Math.ceil((100.0 - progresses[i]) / speeds[i]);
		}
		int count = 0;
		int maxDay = daysLeft[0];

		for (int i = 0; i < n; i++) {
			if (daysLeft[i] <= maxDay) {
				count++;
			} else {
				answer.add(count);
				count = 1;
				maxDay = daysLeft[i];
			} 
		}

		answer.add(count);
		
		return answer.stream().mapToInt(Integer::intValue).toArray();
	}
}

```

### 알게된 점

- deque의 기능에만 집중하다보니 일반 배열로 풀어야하는 걸 모르고 접근한 탓이 큰것 같다. 문제에 어떤 자료구조를 적용할지 연습이 더 필요하다.
- 갈수록 Math 함수에 대한 활용이 늘고 있다. math에 대해서 한번더 정리할 필요가 있을듯 -> 코테에 많이 사용되는 것 위주로