# 올바른 괄호

---
### 📌 문제 링크
- 이름: [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)
- 난이도: Level 2
- 풀이 날짜: 2024-12-02

### 👓 문제 설명

괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어

- "()()" 또는 "(())()" 는 올바른 괄호입니다.
- ")()(" 또는 "(()(" 는 올바르지 않은 괄호입니다.
- '(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.

### 🚫 제한사항

- 문자열 s의 길이 : 100,000 이하의 자연수
- 문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.

### 🖥️ 입출력 예

| Input | Valid Parentheses |
|-------|------------------|
| "()()" | true |
| "(())()" | true |
| ")()(" | false |
| "(()("|  false |


### ⏱️ 소요 시간

- 분석: 6분
- 구현: 22분
- 총 소요: 28분

### 💡 접근 방법

---
1. 첫 번째 접근
    - 괄호가 올바르게 짝 지어지는 것을 판단하는 문제이므로, Stack을 이용한다.
    - 한 글자마다 연산을 처리해야하므로 `StringTokenizer`를 이용하여 한 글자씩 분리된 값을 이용
    1. `Stack` 이 비어있거나, 올바른 짝을 찾지 못할경우에는 `push()` 연산을 수행
    2. `Stack` 에 저장된 문자열에 대하여 `peek()` 연산 수행시 문자열이 '('이며 다음으로 처리되는 토큰의 값이 ')' 일 경우 올바른 괄호가 완성되기 때문에 다음 토큰 값을 저장하지 않고, `pop()` 연산을 수행
    - 해당 로직이 정상적으로 처리 되는 경우 문자열이 올바른 괄호일 경우 `isEmpty()` 값은 `true` 아닐 경우 `false` 이기 때문에 `stack.isEmpty()` 값을 반환
    - 시간 복잡도 : $O(N)$

```java
static StringTokenizer tokenizer;
static Stack<String> stack = new Stack<>();

boolean solution(String s) {
	boolean answer = true;
	tokenizer = new StringTokenizer(s);
	while (tokenizer.hasMoreTokens()) {
		String token = tokenizer.nextToken();
		if (stack.isEmpty()) {
			stack.push(token);
		} else {
			validateToken(token);
		}
	}
	return stack.isEmpty();
}

private void validateToken(String token) {
	if (stack.peek().equals("(") && token.equals(")")) {
		stack.pop();
	} else {
		stack.push(token);
	}
}

```

2. 최종 접근
    - `StringTokenizer`로 한글자씩 연산을 처리하였지만, 인식하지 못하여 `split("")` 연산을 이용
    - 테스트 케이스의 처리와 정확성 테스트는 완료 했지만, 효율성 테스트에서 실패
        1. 불필요한 `if`문 제거
        2. `split("")` 연산을 수행하지 않고, 입력 값 `s` 에 대하여 `for`문 내부에 `s.charAt(i)` 값을 `validateToken`의 인자값으로 받아 로직 수행
    - 적용 후 효율성 테스트 통과 완료


### 🔍 제출
```java
import java.util.Stack;
import java.util.StringTokenizer;

class Solution {
    
	static Stack<String> stack = new Stack<>();
    
	boolean solution(String s) {
		for (int i = 0; i < s.length(); i++) {
			validateToken(String.valueOf(s.charAt(i)));
		}
		return stack.isEmpty();
	}

	private void validateToken(String token) {
		if (!stack.isEmpty() && (stack.peek().equals("(") && token.equals(")"))) {
			stack.pop();
		} else {
			stack.push(token);
		}
	}
}
```

### 알게된 점
- 습관적으로 입력값을 처리하는 과정에서` BufferedStream -> String.split()`을 이용하였는데 해당 과정 또한 하나의 연산으로 풀이의 효율성을 낮추는 결과를 나오게 될 줄 몰랐다. 알고리즘 작성시 하드코딩은 지양하지만 필요할때 적재적소에 활용할 수 있는 마인드가 필요할 듯.
- 단순 처리시 `StringTokenizer` 와 `String.split("")`대신에 `String.charAt()` 활용