# 오픈채팅방

## 📌 문제 정보
- **문제**: [오픈채팅방](https://school.programmers.co.kr/learn/courses/30/lessons/42888)
- **카테고리**: 문자열 처리, 해시
- **플랫폼**: Programmers

## 👓 문제 설명
카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 진행할 수 있으며, 사용자는 실제 닉네임이 아닌 가상의 닉네임으로 채팅방에 들어갈 수 있습니다.  
신입사원인 김크루는 오픈채팅방의 기록을 바탕으로 관리자가 채팅방의 입장, 퇴장, 닉네임 변경 기록을 한눈에 확인할 수 있는 기능을 구현하려고 합니다.  
프로그램은 아래와 같이 동작합니다.

- **입장 시**: "[닉네임]님이 들어왔습니다."
- **퇴장 시**: "[닉네임]님이 나갔습니다."
- **닉네임 변경 시**: 기존 기록에 있는 닉네임도 모두 최신 닉네임으로 갱신됩니다.

## 🚫 제한사항
- `record` 배열의 길이는 1 이상 100,000 이하
- 각 기록 문자열은 공백으로 구분된 단어들로 구성되며, 형식은 다음과 같습니다.
    - `"Enter [유저 아이디] [닉네임]"`: 해당 유저가 채팅방에 입장합니다.
    - `"Leave [유저 아이디]"`: 해당 유저가 채팅방을 퇴장합니다.
    - `"Change [유저 아이디] [닉네임]"`: 해당 유저가 닉네임을 변경합니다.
- 모든 유저는 `유저 아이디`로 구분하며, 유저 아이디와 닉네임은 알파벳 대소문자와 숫자로 구성되고 길이는 1 이상, 10 이하입니다.
- 잘못된 입력은 주어지지 않습니다.

## 🖥️ 입출력 예
| record                                                                                                            | result                                                                                                       |
|-------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------|
| `["Enter uid1234 Muzi", "Enter uid4567 Prodo", "Leave uid1234", "Enter uid1234 Prodo", "Change uid4567 Ryan"]` | `["Prodo님이 들어왔습니다.", "Ryan님이 들어왔습니다.", "Prodo님이 나갔습니다.", "Prodo님이 들어왔습니다."]`

## 📝 입출력 예 설명
- `"Enter uid1234 Muzi"`: uid1234가 "Muzi"라는 닉네임으로 채팅방에 입장합니다.
- `"Enter uid4567 Prodo"`: uid4567가 "Prodo"라는 닉네임으로 채팅방에 입장합니다.
- `"Leave uid1234"`: uid1234가 채팅방을 퇴장합니다.
- `"Enter uid1234 Prodo"`: uid1234가 "Prodo"라는 닉네임으로 다시 입장하며, 이 때 기존의 입장 기록에서도 닉네임이 "Prodo"로 갱신됩니다.
- `"Change uid4567 Ryan"`: uid4567가 닉네임을 "Ryan"으로 변경하면, uid4567과 관련된 모든 이전 기록의 닉네임이 "Ryan"으로 변경됩니다.

결과적으로 최종 출력 메시지는 아래와 같이 구성됩니다.

- "Prodo님이 들어왔습니다."
- "Ryan님이 들어왔습니다."
- "Prodo님이 나갔습니다."
- "Prodo님이 들어왔습니다."

```java
import java.util.*;

class Solution {
	static Map<String, String> map = new HashMap<>();
	static List<String> list = new ArrayList<>();
	static List<String> resultList = new ArrayList<>();

	public String[] solution(String[] record) {
		process(record);
		for (String result : list) {
			StringTokenizer tokenizer = new StringTokenizer(result, "#");
			StringBuilder builder = new StringBuilder();
			String nickName = map.get(tokenizer.nextToken());
			builder.append(nickName);
			builder.append(tokenizer.nextToken());
			resultList.add(builder.toString());
		}
		return resultList.toArray(String[]::new);
	}

	public static void process(String[] record) {
		for (String column : record) {
			StringTokenizer st = new StringTokenizer(column, " ");
			String act = st.nextToken();
			String uid = "";
			String nickName = "";
			switch (act) {
				case "Enter":
					uid = st.nextToken();
					nickName = st.nextToken();
					if (map.containsKey(uid) && map.get(uid).equals(nickName)) {
						list.add(uid + "#님이 들어왔습니다.");
					} else {
						map.put(uid, nickName);
						list.add(uid + "#님이 들어왔습니다.");
					}
					break;
				case "Leave":
					uid = st.nextToken();
					list.add(uid + "#님이 나갔습니다.");
					break;
				case "Change":
					uid = st.nextToken();
					nickName = st.nextToken();
					map.put(uid, nickName);
					break;
			}
		}

	}

}
```

- 해당 문제의 값은 최종 결과만을 원하기 때문에 uid로 문장을 만들어두고, 해당 record에서 입력되는 커맨드에 따른 닉네임 변화는 Map의 값을 변화 시키는 과정 진행후 uid에 매핑되는 닉네임을 넣는 방법으로 구현을 완료하였다.
- 문제를 접근할때 최종 결과를 원하는지 아니면 다른 결과값을 원하는지 체크할 필요가 있다.