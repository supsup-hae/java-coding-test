# 짝지어 제거하기

---

### 📌 문제 링크

- 이름: [짝지어 제거하기](https://school.programmers.co.kr/learn/courses/30/lessons/12973)
- 난이도: Level 2
- 풀이 날짜: 2024-12-04

### 👓 문제 설명

알파벳 소문자로 이루어진 문자열에서 같은 알파벳이 2개 붙어있는 짝을 찾아 제거하고, 앞뒤로 문자열을 이어 붙이는 과정을 반복하여 문자열을 모두 제거할 수 있는지 판단하는 문제입니다.

예시:
문자열 S = baabaa인 경우

1. b aa baa → bb aa → aa →
2. 문자열이 모두 제거되므로 1을 반환

### 🚫 제한사항

- 문자열의 길이: 1,000,000 이하의 자연수
- 문자열은 모두 소문자로 이루어져 있습니다

### 🖥️ 입출력 예

| s      | result |
|--------|--------|
| baabaa | 1      |
| cdcd   | 0      |

### ⏱️ 소요 시간

* [x] **제한 시간 내 풀이**
    - 분석: 4분
    - 구현: 10분
    - 총 소요: 14분
* [ ] **시간 초과**

### 💡 접근 방법

1. 첫 번째 접근
    - 같은 문자열을 제거하는 과정에서`Stack`을 활용할 수 있다고 생각했고, 스택이 비어있을 경우를 제외
    - 스택에 다음으로 삽입될 요소가 `peek()` 한 요소와 같을 경우
        1. `true` : `pop()` 으로 요소를 제거후 다음 요소 비교 진행
        2. `false` : `Stack`에 삽입

2. 최종 접근
    - 정확성 테스트 이후 효율성 테스트도 진행하였지만, 기존의 문제풀이를 본 받아 최소한의 시간 복잡도를 가지도록 코드를 설계
    - 시간 복잡도 : $O(N)$

### 🔍 제출 코드

```java
import java.util.Stack;
import java.util.StringTokenizer;

class Solution {
	static int answer = 0;
	static Stack<Character> stack = new Stack<>();

	public int solution(String s) {
		for (int i = 0; i < s.length(); i++) {
			if (!stack.isEmpty() && stack.peek().equals(s.charAt(i))) {
				stack.pop();
			} else {
				stack.push(s.charAt(i));
			}
		}
		return stack.isEmpty() ? 1 : 0;
	}
}
```

### 알게된 점

- 문제를 푼 만큼 아는게 보인다.