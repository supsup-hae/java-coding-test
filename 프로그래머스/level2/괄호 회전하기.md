# 괄호 회전하기

---

### 📌 문제 링크

- 이름: [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)
- 난이도: Level 2
- 풀이 날짜: 2024-12-03

### 👓 문제 설명

- 다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

1. `(), [], {}` 는 모두 올바른 괄호 문자열입니다.
2. 만약 A가 올바른 괄호 문자열이라면, `(A), [A], {A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
3. 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

- 대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 $x (0 ≤ x < (s의 길이))$ 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를
  `return` 하도록 `solution` 함수를 완성해주세요.

### 🚫 제한사항

- s의 길이는 1 이상 1,000 이하입니다.

### 🖥️ 입출력 예

| Input  | Valid Parentheses |
|--------|-------------------|
| [](){} | 3                 |
| }]()[{ | 2                 |
| [)(]   | 0                 |
| }}}    | 0                 |

### ⏱️ 소요 시간

- 분석: 8분
- 구현: 30분
- 총 소요: 38분

### 💡 접근 방법

---

1. 첫 번째 접근
    - 괄호가 올바르게 짝 지어지는 것을 판단하는 문제이므로, `Stack`을 이용한다.
    - String 의 `+` 연산은 O(N), `StringBuilder`의 `append()` 는 $O(1)$의 시간 복잡도를 소요하기에 후자를 선택
    - 입력값을 왼쪽으로 회전 시키며 검증해야하기 때문에 `subString()`을 이용하여 `s`의 `i` 번째 값을 기준으로 값을 회전하여 `StringBuilder`에 적용
    - 연산 메소드를 분리하여 각 회전 값마다 올바른 괄호 짝이 이뤄지는지 확인
    - 올바른 괄호의 괄호 검증 로직을 사용
        1. `Stack` 이 비어있거나, 올바른 짝을 찾지 못할경우에는 `push()` 연산을 수행
        2. `Stack` 에 저장된 문자열에 대하여 `peek()` 연산 수행시 문자열이 '('이며 다음으로 처리되는 토큰의 값이 ')' 일 경우 올바른 괄호가 완성되기 때문에 다음 토큰 값을 저장하지
           않고, `pop()` 연산을 수행

        - 해당 로직이 정상적으로 처리 되는 경우 문자열이 올바른 괄호일 경우 `isEmpty()` 값은 `true` 아닐 경우 `false` 이기 때문에 `stack.Empty()`일 경우
          `answer++` 연산이 진행된다.
    - 반복문 종료후의 `answer` 값을 반환하면 구현 완료

    - 시간 복잡도 : $O(N^2)$

```java
    public int solution(String s) {

	for (int i = 0; i < s.length(); i++) {
		if (i != 0) {
			stringBuilder.append(s.substring(i, s.length()));
			stringBuilder.append(s.substring(0, i));
		} else {
			stringBuilder.append(s);
		}
		validate(stringBuilder);
	}
	return answer;
}

private void validate(StringBuilder stringBuilder) {
	String value = stringBuilder.toString();
	System.out.println("value =" + value);
	char[] charArray = value.toCharArray();
	for (int i = 0; i < charArray.length; i++) {
		if (!stack.isEmpty() && (stack.peek().equals('(')) && charArray[i] == ')') {
			stack.pop();
		} else if (!stack.isEmpty() && stack.peek().equals('{') && charArray[i] == '}') {
			stack.pop();
		} else if (!stack.isEmpty() && stack.peek().equals('[') && charArray[i] == ']') {
			stack.pop();
		} else {
			stack.push(charArray[i]);
		}
	}
	System.out.println("stack :" + stack);
	if (stack.isEmpty()) {
		answer++;
	}
}

```

2. 최종 접근
    - 반복문 마다 StringBuilder와 Stack을 초기화 해주는 것을 깜박하고 이를 검증하는데 시간이 오래 소요되었다.

### 🔍 제출

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Solution {

	static Stack<Character> stack;
	static List<StringBuilder> list = new ArrayList<>();
	StringBuilder stringBuilder;
	static int answer = 0;

	public int solution(String s) {

		for (int i = 0; i < s.length(); i++) {
			stringBuilder = new StringBuilder();
			if (i != 0) {
				stringBuilder.append(s.substring(i, s.length()));
				stringBuilder.append(s.substring(0, i));
			} else {
				stringBuilder.append(s);
			}
			validate(stringBuilder);
		}
		return answer;
	}

	private void validate(StringBuilder stringBuilder) {
		stack = new Stack<>();
		char[] charArray = stringBuilder.toString().toCharArray();
		for (int i = 0; i < charArray.length; i++) {
			if (!stack.isEmpty() && (stack.peek().equals('(')) && charArray[i] == ')') {
				stack.pop();
			} else if (!stack.isEmpty() && stack.peek().equals('{') && charArray[i] == '}') {
				stack.pop();
			} else if (!stack.isEmpty() && stack.peek().equals('[') && charArray[i] == ']') {
				stack.pop();
			} else {
				stack.push(charArray[i]);
			}
		}
		if (stack.isEmpty()) {
			answer++;
		}
	}
}

```

### 알게된 점

- 코테 문제를 풀면 풀수록 util에서 지원하는 method들의 활용을 더 많이 시도해볼 수 있는것 같다. 문제 푸는 빈도수를 올리는게 도움이 될 듯.
- 전역 변수 사용후 로직 계산시 초기화를 하지 않아 원하는 결과 값이 나오지 않는 경우가 빈번하다. 알고리즘 파악시 같이 정리할 필요가 있다.