# 표 편집

## 📌 문제 정보
- **문제**: [표 편집](https://school.programmers.co.kr/learn/courses/30/lessons/81303)
- **난이도**: Level 3
- **유형**: 구현, 자료구조

## 👓 문제 설명
업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 표의 행을 선택하고 편집하는 명령어는 다음과 같습니다[1]:

- `"U X"`: 현재 선택된 행에서 X칸 위에 있는 행을 선택
- `"D X"`: 현재 선택된 행에서 X칸 아래에 있는 행을 선택
- `"C"`: 현재 선택된 행을 삭제하고 바로 아래 행을 선택 (마지막 행인 경우 윗 행 선택)
- `"Z"`: 가장 최근에 삭제된 행을 복구 (선택된 행은 바뀌지 않음)

## 🚫 제한사항
- 5 ≤ n ≤ 1,000,000
- 0 ≤ k < n
- 1 ≤ cmd의 원소 개수 ≤ 200,000
- X는 1 이상 300,000 이하인 자연수
- cmd에 등장하는 모든 X들의 합은 1,000,000 이하
- 표의 모든 행이 제거되는 경우는 입력으로 주어지지 않음

## 🖥️ 입출력 예
| n | k | cmd | result |
|---|---|-----|--------|
| 8 | 2 | ["D 2","C","U 3","C","D 4","C","U 2","Z","Z"] | "OOOOXOOO" |
| 8 | 2 | ["D 2","C","U 3","C","D 4","C","U 2","Z","Z","U 1","C"] | "OOXOXOOO" |

## 📝 입출력 예 설명
첫 번째 예시는 문제의 예시와 동일합니다. 두 번째 예시는 처음 9개의 명령어까지는 첫 번째 예시와 동일하게 수행된 후, "U 1"과 "C" 명령어가 추가로 수행되어 최종적으로 두 개의 행이 삭제된 상태가 됩니다[1].

## ⏰ 제한시간
- 정확성 테스트: 10초
- 효율성 테스트: 언어별 작성된 정답 코드의 실행 시간의 적정 배수[1]

* [ ] **제한 시간 내 풀이**
* [x] **시간 초과**

### 💡 접근 방법

1. 초기 접근
   1. 삭제 및 복구에 관한 로직은 Stack을 이용해서 구현하고, 인덱스의 조회와 현재 위치등은 list를 이용한 방식으로 접근
         - 하지만 list를 이용시 삭제 후 복구 되는 인덱스를 지정하는 과정에서 리스트의 특징인 동적 사이즈에 의해 로직 구현시 복구되는 값이 원하는 인덱스에 삽입 되지 않는 문제 발생
   2. list의 문제점을 깨닫고 array로 바꾸어 로직을 구현하였지만 문제에서 인덱스가 이동하는 과정은 동적 사이즈를 기반으로 진행되기 때문에 이를 해결하짐 못하고 실패
        - 테스트 1번은 넘겼지만 2번에서 문제가 발생하였다. 테스트만보고 해당하는 요구 값에 맞추려고 구현하려는 나쁜 버릇이다.
```java

import java.util.Arrays;
import java.util.List;
import java.util.Stack;
import java.util.stream.Collectors;

public class Solution {
	static Stack<Integer> stack = new Stack<>();
	static int[] array;
	static StringBuilder sb = new StringBuilder();
	static int current;
	static int MIN = 0;
	static int MAX;

	public String solution(int n, int k, String[] cmd) {
		current = k;
		MAX = n;
		array = new int[n];
		for (int i = 0; i < MAX; i++) {
			array[i] = i;
		}
		for (int i = 0; i < cmd.length; i++) {
			if (cmd[i].contains("U")) {
				moveUp(cmd[i]);
			} else if (cmd[i].contains("D")) {
				moveDown(cmd[i]);
			} else if (cmd[i].contains("C")) {
				deleteCell();
			} else if (cmd[i].contains("Z")) {
				redoCell();
			}
		}
		System.out.println(array);
		List<Integer> list = Arrays.stream(array).boxed().collect(Collectors.toList());
		for (int i = 0; i < MAX; i++) {
			if (list.contains(i)) {
				sb.append("O");
			} else {
				sb.append("X");
			}
		}
        		System.out.println( sb.toString());
		return sb.toString();
	}

	private static void redoCell() {
		int value = stack.pop();
		array[value] = value;
        current++;
		validate();
	}

	private static void deleteCell() {
		stack.add(current);
		array[current] = 0;
		current++;
		validate();
	}

	private static void moveDown(String cmd) {
		String number = cmd.split(" ")[1];
		current += Integer.parseInt(number);
		validate();
	}

	private static void moveUp(String cmd) {
		String number = cmd.split(" ")[1];
		current -= Integer.parseInt(number);
		validate();
	}

	private static void validate() {
		if (current > array.length) {
			current = array.length -1;
		} else if (current < MIN) {
			current = MIN;
		}
	}

}

```

2. 최종 접근
    - 문제 풀이에서는 실제 배열을 선언하고 삽입 삭제 연산 대신 인덱스만을 이용해서 연산을 진행하였다.
    - `up` `down` 배열을 각각 만들어 기존 배열에서의 상단과 하단 인덱스를 저장할 수 있도록 초기에 별도로 지정
    - 삭제 복구시 해당하는 배열마다 값을 갱신하는 과정을 거치며 삭제한 값은 Stack에 보관하여 `push()`, `pop()` 연산을 통해 관리

### 🔍 정답 코드

```java
import java.util.Arrays;
import java.util.Stack;

class Solution {
   public String solution(int n, int k, String[] cmd) {
      // ❶ 삭제된 행의 인덱스를 저장하는 스택
      Stack<Integer> deleted = new Stack<>();
      // ❷ 각 행을 기준으로 연산에 따른 위치를 표시하기 위한 배열
      int[] up = new int[n + 2];
      int[] down = new int[n + 2];

      for (int i = 0; i < n + 2; i++) {
         up[i] = i - 1;
         down[i] = i + 1;
      }

      // ❸ 현재 위치를 나타내는 인덱스
      k++;

      // ❹ 주어진 명령어(cmd) 배열을 하나씩 처리
      for (String c : cmd) {
         // ❺ 현재 위치를 삭제하고 그 다음 위치로 이동
         if (c.startsWith("C")) {
            deleted.push(k);
            up[down[k]] = up[k];
            down[up[k]] = down[k];
            k = n < down[k] ? up[k] : down[k];
         }
         // ❻ 가장 최근에 삭제된 행을 복원
         else if (c.startsWith("Z")) {
            int restore = deleted.pop();
            down[up[restore]] = restore;
            up[down[restore]] = restore;
         }
         // ❼ U 또는 D를 사용해 현재 위치를 위, 아래로 이동
         else {
            String[] s = c.split(" ");
            int x = Integer.parseInt(s[1]);
            for (int i = 0; i < x; i++) {
               k = s[0].equals("U") ? up[k] : down[k];
            }
         }
      }

      // ❽ 삭제된 행의 위치에 ‘X’를, 그렇지 않은 행 위치에는 ‘O’를 저장한 문자열 반환
      char[] answer = new char[n];
      Arrays.fill(answer, 'O');

      for (int i : deleted) {
         answer[i - 1] = 'X';
      }

      return new String(answer);
   }
}
```

### 알게된 점

- 문제를 읽고 우습게 보았다가 된통 당했다. 역시 level3인 이유가 있는거 같다. 