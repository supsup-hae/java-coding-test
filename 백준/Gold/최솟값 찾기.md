# 최솟값 찾기

---

### 📌 문제 링크

- 이름: [최솟값 찾기](https://www.acmicpc.net/problem/11003)
- 난이도: Gold 1
- 풀이 날짜: 2024-12-03

### 👓 문제 설명

`N`개의 수와 `L`이 주어질 때, `i`번째 수부터 `L`개의 수들 중에서 최솟값을 구하는 문제입니다. 이때 $D_i = A_{i-L+1} ~ A_i$ 중의 최솟값을 구해야 하며, $i ≤ 0$인 $A_i$는 무시해야 합니다.

### 🚫 제한사항

- $1 ≤ L ≤ N ≤ 5,000,000$
- $-109 ≤ A_i ≤ 109$
- 시간 제한: 2.4초
- 메모리 제한: 512MB

### 🖥️ 입출력 예

| 입력                              | 출력                      |
|---------------------------------|-------------------------|
| 12 3<br>1 5 2 3 6 2 3 7 3 5 2 6 | 1 1 1 2 2 2 2 2 3 3 2 2 |

### ⏱️ 소요 시간

* [ ] **제한 시간 내 풀이**
    - 분석:
    - 구현:
    - 총 소요:
* [x] **시간 초과**

### 💡 접근 방법

---

1. **첫 번째 접근**
    - 내부 클래스를 생성하여 문제를 해결하는 방식에 익숙치 않아 기현이가 추천해준 문제
    - 문제 조건을 이해하는데 시간이 좀 걸렸다 각 시작점 `i` 마다 주어진 `L` 만큼의 별도의 배열이 생성되고 해당 배열 내부에서 최솟값을 확인 하는 과정을 수행하기 위해 `Minimum` 클래스를 생성
    - `Minimum` 클래스 내부에서 생성자를 통해서 배열을 전달해주면 `getMinValue()` 를 이용하여 최솟값을 `Stream`을 이용해서 도출하고, 이를 따로 배열에 저장하지 않고 바로 반환
      문자열에 포함시켰다.
    - 제약 조건인 i <=0 인 A_i를 무시하기 위해서 `condition` 을 따로 정의하여 제약 조건에 따른 로직을 수행하도록 작성했다.
    - 시간 복잡도 : $O(N^2)$

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

	static int N;
	static int L;
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringBuilder sb = new StringBuilder();

	public static void main(String[] args) throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		N = Integer.parseInt(st.nextToken());
		L = Integer.parseInt(st.nextToken());
		int[] array = new int[N];
		String[] split = br.readLine().split(" ");

		for (int i = 0; i < split.length; i++) {
			array[i] = Integer.parseInt(split[i]);
		}

		for (int i = 0; i < array.length; i++) {
			int condition = i - L + 1;
			if (i != array.length - 1 && condition <= 0) {
				sb.append(array[0] + " ");
			} else {
				Minimum minimum = new Minimum(Arrays.copyOfRange(array, condition, i + 1));
				sb.append(minimum.minValue + " ");
			}
		}
		System.out.println(sb.toString());
	}

	static class Minimum {
		int[] D_Array;
		int minValue;

		public Minimum(int[] d_Array) {
			D_Array = d_Array;
			this.minValue = getMinValue();
		}

		public int getMinValue() {
			return Arrays.stream(D_Array).min().getAsInt();
		}
	}
}

```

2. **최종 접근** (시간 초과로 답안 확인)
    - 제한 시간에 맞추어 작성은 완료하고, 테스트 케이스의 작동을 정삭적으로 확인 했지만, 메모리 초과로 문제 해결은 실패하였다.
        - 기존 `StringTokenizer`를 사용하는 과정에서 입력값 처리시 오류가 발생하여 급히 `split()` 으로 방향을 바꾼게 문제가 된걸까?
    - 슬라이딩 윈도우 알고리즘, `Deque` 를 이용한 문제풀이가 이루어졌다. (알고리즘 파트에 따로 정리 필요)
    - `Deque`의 특성을 이용하여 `now` 의 값보다 큰 값은 모두 삭제 `removeLast()`, `now`의 index가 제약조건을 벗어 날경우 `removeFirst()`
    - 로직 수행후 `Deque` 에는 최솟값만 존재하기 때문에 이를 `BufferedWriter` 에 담아 출력

### 🔍 제출

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;
import java.util.Deque;
import java.util.LinkedList;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		// 입력 개수 N과 구간 수 L 입력
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int L = Integer.parseInt(st.nextToken());

		// N개의 수 입력
		st = new StringTokenizer(br.readLine());

		// 값을 보관 및 정렬 해 줄 deque
		Deque<Node> mydeque = new LinkedList<>();

		for (int i = 0; i < N; i++) {
			int now = Integer.parseInt(st.nextToken());

			// 덱이 비거나, 덱 마지막에 현재 값(now)보다 큰 값 지우기
			while (!mydeque.isEmpty() && mydeque.getLast().value > now)
				mydeque.removeLast();

			// 덱 마지막에 값 삽입
			mydeque.addLast(new Node(i, now));

			// 덱의 첫번째 인덱스에서 범위를 벗어난 값 지우기
			while (mydeque.getFirst().index <= i - L)
				mydeque.removeFirst();

			// 최소값 출력
			bw.write(mydeque.getFirst().value + " ");
		}
		bw.flush();
	}
}

class Node {
	public int index, value;

	public Node(int index, int value) {
		this.index = index;
		this.value = value;
	}
}

```

### 알게된 점

- 시간 제한이 촉박할 경우 `BufferedReader` 뿐만 아니라 `BufferedWriter`를 사용하는 것을 권장, 해당 실수는 프로그래머스와 백준의 문제 풀이 방법이 상이하기때문에 나타나는 문제점으로 의식하며 코드를
  작성할 필요가 있다.
- 별도의 클래스를 생성하여 문제를 해결하는 방안은 나에게 익숙한 접근 방법이 아니다. 문제를 제대로 이해하고 알고리즘의 유형에 따라서 문제 풀이 방법을 습득할 필요가 있다.
- `Deque`의 특징과 슬라이딩 윈도우 알고리즘에 대하여 별도로 정리할 필요가 있다.

